
# PODNAME: Text::Parser::Manual::ExtendedAWKSyntax

# ABSTRACT: A manual for ExAWK (extended AWK) syntax

=head1 BASIC STRUCTURE

The basic syntax of the AWK program is:

    condition { task; }

The form of the ExAWK rule is like this:

    if => 'condition', do => 'task'

B<Note:> You I<must> enclose your string C<condition> and C<task> in single quotes. If the single quotes are missing, you will get garbage or the expression will fail to compile. It is important to note that I recommend the use of single quotes C<'> and not double quotes C<"> for a reason. Read on.

Either C<condition> or C<task> must be supplied. If neither is supplied, an exception will be thrown.

The language for the C<condition> and C<task> is Perl (not AWK). So for example, to compare strings you should use C<eq> and not C<==> like you would in AWK. If the C<'if'> and C<'do'> strings do not compile to form kosher Perl code, you'll get an exception.

=head2 Simplicity like AWK

Just as in AWK the C<condition> can be as simple as a regular expression, or a complex boolean expression. In AWK you could do:

    $ awk '/EMAIL:/ {print $2}' file.txt

In ExAWK you could write something like this to get something equivalent (Note the need for C<"\n">):

    if => 'm/EMAIL:/', do => 'print $2, "\n"'

The default C<condition> in ExAWK is just like in AWK: true for each input line. The default C<task> in AWK is C<print>. Thus:

    $ awk '/li/' file.txt

will print all the lines with C<'li'> somewhere in it. But in ExAWK, since it integrates with the L<Text::Parser> class, the default task is C<return $0;>. This means that if you provide a condition but not a task, in ExAWK, the default is to return the line as it is.

    if => 'm/li/'  # returns each line that contains 'li' in it.

If you want to C<print> instead and not record anything, you need to specify that:

    if => 'm/li/', do => 'print', dont_record => 1

Notice the similarity to the AWK syntax: 

    $ awk '/li/ {print}' file.txt

Like AWK, C<$0> identifies the whole line.

In ExAWK, the Perl in-built variable C<$_> is also set to the current line. So any in-built functions that take a missing parameter to be C<$_> will behave accordingly. Thus your conditional expressions could be something like:

    if => 'm/EMAIL:/'

=head1 ACCESSING POSITIONAL FIELDS

=head2 Field identifiers

AWK is very popular for its intuitive field identifiers C<$1>, C<$2>, C<$3> etc. ExAWK provides the same and much more.

It is B<important> to note that C<$1>, C<$2>, etc., are not variables, even in AWK. They are just I<positional field identifiers>. They represent an Rvalue and cannot be modified. So for example

    $ awk '// {$1 == "something";}' file.txt

will not accomplish anything. The same is true in ExAWK.

The ExAWK identifiers C<$1>, C<$2> etc., are not the same as the native Perl variables C<$1>, C<$2> etc. These native Perl variables exist only in regexp substitutions. The I<positional field identifiers> C<$1>, C<$2> etc. exist only inside the I<string> expressions in ExAWK.

=head2 Reverse field identifiers

Now we add new features that really go beyond AWK. To access fields from the end of the line, use identifiers C<${-1}>, C<${-2}>, etc.

=head3 Automatic checks for NF

You don't need to bother about the existence of a field when you write these expressions. For example, in AWK if you write:

    $ awk '$4 == ""' text.txt

then all lines with 3 or less fields will automatically be printed to the screen because C<$4> evaluates to empty string when there are less than 4 fields on a line. But in ExAWK:

    if => '$4 eq ""'

would never be true. Furthermore, if you had written a rule like this in AWK:

    $ awk '$1 == "MIDDLE" && $2 == "NAME:" {print toupper($3)}' file.txt

You could still get empty lines for each person that has no middle name.

Instead, in ExAWK, the following rule:

    if => '$1 eq "MIDDLE" and $2 eq "NAME:"', do => 'return uc($3)'

would automatically check that there are at least three fields on the line. This means it will never return anything in case of people with no middle names.

=head2 The C<$this> variable

Sometimes you want to access specific attributes of your parser class, or maybe you want to call a method. The C<$this> variable is accessible in both the C<condition> and the C<task> strings.

Note that this is a real variable. If you modify the value of C<$this>, it will change.

=head1 DIFFERENCES BETWEEN AWK and ExAWK

=for :list
* AWK cannot store very complex data structures. ExAWK can.
* In UNIX implementation of AWK, the positional variables are limited to C<$9>. In POSIX implementations this limitation has already been removed. We also remove this limit.
* In AWK there are no positional variables for positions counted from the end. In ExAWK, you have C<${-1}>, C<${-2}>, C<${-3}> etc.
* In AWK if you use a positional variable like C<$8> when there are only 7 fields on a line, it evaluates to empty string. In ExAWK, if you use C<$8> in any of the strings, an automatic pre-condition is generated to check that there must be at least 8 fields on the input line.

