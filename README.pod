=pod

=encoding UTF-8

=head1 NAME

Text::Parser - Simplifies text parsing. Easily extensible to parse any text format.

=head1 VERSION

version 0.928

=head1 SYNOPSIS

The following prints the content of the file (named in the first argument) to C<STDOUT>.

    use Text::Parser;

    my $parser = Text::Parser->new();
    $parser->read(shift);
    print $parser->get_records, "\n";

The earlier code prints after reading the whole file, this one prints immediately.

    my $parser = Text::Parser->new();
    $parser->add_rule(do => 'print', dont_record => 1);
    $parser->read(shift);       # Runs the rule for each line of input file

Here is a more common example:

    my $parser = Text::Parser->new();
    $parser->add_rule(
        if => '$1 eq "ERROR:"',
            # $1 is a positional identifier for first field on the line
        do => '$this->abort_reading; return $_;'
            # $this is copy of $parser accessible from within the rule
            # abort_reading() tells parser to stop reading further
            # Returned values are saved as records. Any data structure can be saved.
            # $_ contains the full line as string, including any whitespaces
    );
    
    # Reads all lines until it encounters "ERROR:"
    $parser->read('/path/to/logfile');

    # Print a message if ...
    print "Some errors were found:\n" if $parser->get_records();

Much more complex file-formats can be read and data in it could be stored in a data-structure:

    use strict;
    use warnings;

    package ComplexFormatParser;
    
    use Text::Parser::RuleSpec;  ## provides applies_rule + other sugar, imports Moose
    extends 'Text::Parser';

    # This rule ignores all comments
    applies_rule ignore_comments => (
        if          => 'substr($1, 0, 1) eq "#"', 
        dont_record => 1, 
    );

    # An attribute of the parser class. 
    has current_section => (
        is         => 'rw', 
        isa        => 'Str', 
        default    => undef, 
    );

    applies_rule get_header => (
        if          => '$1 eq "SECTION"', 
        do          => '$this->current_section($2);',  # $this : this parser object
        dont_record => 1, 
    );

    # ... More can be done

    package main;
    use ComplexFormatParser;

    my $p = ComplexFormatParser->new();
    $p->read('myfile.complex.fmt');

=head1 OVERVIEW

The L<need|Text::Parser::Manual/MOTIVATION> for this class stems from the fact that text parsing is the most common thing that programmers do, and yet there is no lean, simple way to do it efficiently. Most programmers still write boilerplate code with a C<while> loop.

Instead C<Text::Parser> allows programmers to parse text with simple, self-explanatory L<rules|Text::Parser::Manual::ExtendedAWKSyntax>, whose structure is very similar to L<AWK|https://books.google.com/books/about/The_AWK_Programming_Language.html?id=53ueQgAACAAJ>, but extends beyond the capability of AWK.

I<B<Sidenote:>> Incidentally, AWK is L<one of the ancestors of Perl|http://history.perl.org/PerlTimeline.html>! One would have expected Perl to do way better than AWK. But while you can use Perl to do what AWK already does, that is usually limited to one-liners like C<perl -lane>. Even C<perl -lan script.pl> is not meant for serious projects. And it seems that L<some people still prefer AWK to Perl|https://aplawrence.com/Unixart/awk-vs.perl.html>. This is not looking good.

With C<Text::Parser>, a developer can focus on specifying a grammar and then simply C<read> the file. The C<L<read|/read>> method automatically runs each rule collecting records from the text input into an internal array. Once read, C<L<get_records|/get_records>> can retrieve the records.

Since C<Text::Parser> is a class, a programmer can subclass it to parses very complex file formats. L<Text::Parser::RuleSpec> provides intuitive rule sugar. Use of L<Moose> is encouraged. And data from parsed files can be turned into very complex data-structures or even objects.

With B<L<Text::Parser>> programmers have the power of Perl combined with the elegance of AWK to parse any text file they wish.

=head1 CONSTRUCTOR

=head2 new

Takes optional attributes as in example below. See section L<ATTRIBUTES|/ATTRIBUTES> for a list of the attributes and their description.

    my $parser = Text::Parser->new(
        auto_chomp      => 0,
        line_wrap       => 'just_next_line',
        auto_trim       => 'b',
        auto_split      => 1,
        FS              => qr/\s+/,
    );

=head1 ATTRIBUTES

The attributes below can be used as options to the C<new> constructor. Each attribute has an accessor with the same name.

=head2 auto_chomp

Read-write attribute. Takes a boolean value as parameter. Defaults to C<0>.

    print "Parser will chomp lines automatically\n" if $parser->auto_chomp;

=head2 auto_split

Read-write boolean attribute. Defaults to C<0> (false). Indicates if the parser will automatically split every line into fields.

If it is set to a true value, each line will be split into fields, and L<a set of methods|/"USE ONLY IN RULES AND SUBCLASS"> become accessible to C<L<save_record|/save_record>> or the rules.

=head2 auto_trim

Read-write attribute. The values this can take are shown under the C<L<new|/new>> constructor also. Defaults to C<'n'> (neither side spaces will be trimmed).

    $parser->auto_trim('l');       # 'l' (left), 'r' (right), 'b' (both), 'n' (neither) (Default)

=head2 FS

Read-write attribute that can be used to specify the field separator to be used by the C<auto_split> feature. It must be a regular expression reference enclosed in the C<qr> function, like C<qr/\s+|[,]/> which will split across either spaces or commas. The default value for this argument is C<qr/\s+/>.

The name for this attribute comes from the built-in C<FS> variable in the popular L<GNU Awk program|https://www.gnu.org/software/gawk/gawk.html>. The ability to use a regular expression is an upgrade from AWK.

    $parser->FS( qr/\s+\(*|\s*\)/ );

C<FS> I<can> be changed. Changes can be made even within a rule, but it would take effect only on the next line.

=head2 line_wrap_style

Read-write attribute used as a quick way to select from commonly known line-wrapping styles. If the target text format allows line-wrapping this attribute allows the programmer to write rules as if they were on a single line.

    $parser->line_wrap_style('trailing_backslash');

Allowed values are:

    trailing_backslash - very common style ending lines with \
                         and continuing on the next line
    spice              - used for SPICE syntax, where on the
                         + next line the (+) continues previous line
    just_next_line     - used in simple text files written to be
                         humanly-readable. New paragraphs start
                         on a new line after a blank line.
    slurp              - used to "slurp" the whole file into
                         a single line.

Read more about L<handling the common line-wrapping styles|/"Common line-wrapping styles">.

=head2 multiline_type

Read-write attribute used mainly if the programmer wishes to specify custom line-unwrapping methods. By default, this attribute is C<undef>, i.e., the target text format will not have wrapped lines. It gets automatically changed when C<line_wrap_style> is set to one of the known line-wrapping styles.

Allowed values for C<multiline_type> are described below, but it can also be set back to C<undef>.

    $parser->multiline_type(undef);
    $parser->multiline_type('join_next');

    my $mult = $parser->multiline_type;
    print "Parser is a multi-line parser of type: $mult" if defined $mult;

=over 4

=item *

If the target format allows line-wrapping I<to the B<next>> line, set C<multiline_type> to C<join_next>.

=item *

If the target format allows line-wrapping I<from the B<last>> line, set C<multiline_type> to C<join_last>.

=back

To know more about how to use this, read about L<specifying custom line-unwrap routines|/"Specifying custom line-unwrap routines">.

=head1 METHODS

These are meant to be called from the C<::main> program or within subclasses.

=head2 add_rule

Takes a hash as input. The keys of this hash must be the attributes of the L<Text::Parser::Rule> class constructor and the values should also meet the requirements of that constructor.

    $parser->add_rule(do => '', dont_record => 1);                 # Empty rule: does nothing
    $parser->add_rule(if => 'm/li/, do => 'print', dont_record);   # Prints lines with 'li'
    $parser->add_rule( do => 'uc($3)' );                           # Saves records of upper-cased third elements

Calling this method without any arguments will throw an exception. The method internally sets the C<auto_split> attribute.

=head2 clear_rules

Takes no arguments, returns nothing. Clears the rules that were added to the object.

    $parser->clear_rules;

This is useful to be able to re-use the parser after a C<read> call, to parse another text with another set of rules. The C<clear_rules> method does clear even the rules set up by C<L<BEGIN_rule|/BEGIN_rule>> and C<L<END_rule|/END_rule>>.

=head2 BEGIN_rule

Takes a hash input like C<add_rule>, but C<if> and C<continue_to_next> keys will be ignored.

    $parser->BEGIN_rule(do => '~count = 0;');

=over 4

=item *

Since any C<if> key is ignored, the C<do> key is required. Multiple calls to C<BEGIN_rule> will append to the previous calls; meaning, the actions of previous calls will be included.

=item *

The C<BEGIN> block is mainly used to initialize some variables.

=item *

By default C<dont_record> is set true. User I<can> change this and set C<dont_record> as false, thus forcing a record to be saved even before reading the first line of text.

=back

=head2 END_rule

Takes a hash input like C<add_rule>, but C<if> and C<continue_to_next> keys will be ignored. Similar to C<BEGIN_rule>, but the actions in the C<END_rule> will be executed at the end of the C<read> method.

    $parser->END_rule(do => 'print ~count, "\n";');

=over 4

=item *

Since any C<if> key is ignored, the C<do> key is required. Multiple calls to C<END_rule> will append to the previous calls; meaning, the actions of previous calls will be included.

=item *

The C<END> block is mainly used to do final processing of collected records.

=item *

By default C<dont_record> is set true. User I<can> change this and set C<dont_record> as false, thus forcing a record to be saved after the end rule is processed.

=back

=head2 read

Takes a single optional argument that can be either a string containing the name of the file, or a filehandle reference (a C<GLOB>) like C<\*STDIN> or an object of the C<L<FileHandle>> class.

    $parser->read($filename);         # Read the file
    $parser->read(\*STDIN);           # Read the filehandle

The above could also be done in two steps if the developer so chooses.

    $parser->filename($filename);
    $parser->read();                  # equiv: $parser->read($filename)

    $parser->filehandle(\*STDIN);
    $parser->read();                  # equiv: $parser->read(\*STDIN)

The method returns once all records have been read, or if an exception is thrown, or if reading has been aborted with the C<L<abort_reading|/abort_reading>> method.

Any C<close> operation will be handled (even if any exception is thrown), as long as C<read> is called with a file name parameter - not if you call with a file handle or C<GLOB> parameter.

    $parser->read('myfile.txt');      # Will close file automatically

    open MYFH, "<myfile.txt" or die "Can't open file myfile.txt at ";
    $parser->read(\*MYFH);            # Will not close MYFH
    close MYFH;

=head2 filename

Takes an optional string argument containing the name of a file. Returns the name of the file that was last opened if any. Returns C<undef> if no file has been opened.

    print "Last read ", $parser->filename, "\n";

The value stored is "persistent" - meaning that the method remembers the last file that was C<L<read|/read>>.

    $parser->read(shift @ARGV);
    print $parser->filename(), ":\n",
          "=" x (length($parser->filename())+1),
          "\n",
          $parser->get_records(),
          "\n";

A C<read> call with a filehandle, will clear the last file name.

    $parser->read(\*MYFH);
    print "Last file name is lost\n" if not defined $parser->filename();

=head2 filehandle

Takes an optional argument, that is a filehandle C<GLOB> (such as C<\*STDIN>) or an object of the C<FileHandle> class. Returns the filehandle last saved, or C<undef> if none was saved.

    my $fh = $parser->filehandle();

Like C<L<filename|/filename>>, C<filehandle> is also "persistent". Its old value is lost when either C<filename> is set, or C<read> is called with a filename.

    $parser->read(\*STDOUT);
    my $lastfh = $parser->filehandle();          # Will return glob of STDOUT

=head2 lines_parsed

Takes no arguments. Returns the number of lines last parsed. Every call to C<read>, causes the value to be auto-reset.

    print $parser->lines_parsed, " lines were parsed\n";

=head2 push_records

Takes an array as input, and stores each element as a separate record. Returns the number of elements in the new array.

    $parser->push_records(qw(insert these as separate records));

=head2 get_records

Takes no arguments. Returns an array containing all the records saved by the parser.

    foreach my $record ( $parser->get_records ) {
        $i++;
        print "Record: $i: ", $record, "\n";
    }

=head2 pop_record

Takes no arguments and pops the last saved record.

    my $last_rec = $parser->pop_record;

=head2 last_record

Takes no arguments and returns the last saved record. Leaves the saved records untouched.

    my $last_rec = $parser->last_record;

=head2 has_aborted

Takes no arguments, returns a boolean to indicate if text reading was aborted in the middle.

    print "Aborted\n" if $parser->has_aborted();

=head2 custom_line_unwrap_routines

This method should be used only when the line-wrapping supported by the text format is not already among the L<known line-wrapping styles supported|/"Common line-wrapping styles">.

Takes a hash argument with required keys C<is_wrapped> and C<unwrap_routine>. Used in setting up L<custom line-unwrapping routines|/"Specifying custom line-unwrap routines">.

Here is an example of setting custom line-unwrapping routines:

    $parser->multiline_type('join_last');
    $parser->custom_line_unwrap_routines(
        is_wrapped => sub {     # A method that detects if this line is wrapped or not
            my ($self, $this_line) = @_;
            return 0 if not defined $self->multiline_type;
            $this_line =~ /^[~]/;
        }, 
        unwrap_routine => sub { # A method to unwrap the line by joining it with the last line
            my ($self, $last_line, $this_line) = @_;
            chomp $last_line;
            $last_line =~ s/\s*$//g;
            $this_line =~ s/^[~]\s*//g;
            "$last_line $this_line";
        }, 
    );

Now you can parse a file with the following content:

    This is a long line that is wrapped around with a custom
    ~ character - the tilde. It is unusual, but hey, we're
    ~ showing an example.

When C<$parser> gets to C<read> this, these three lines get unwrapped and processed by the rules, as if it were a single line.

L<Text::Parser::Multiline> shows another example with C<join_next> type.

=head1 USE ONLY IN RULES AND SUBCLASS

These methods can be used only inside rules, or methods of a subclass. One class of these methods are available only when C<auto_split> is on:

=over 4

=item *

L<NF|Text::Parser::AutoSplit/NF>

=item *

L<fields|Text::Parser::AutoSplit/fields>

=item *

L<field|Text::Parser::AutoSplit/field>

=item *

L<field_range|Text::Parser::AutoSplit/field_range>

=item *

L<join_range|Text::Parser::AutoSplit/join_range>

=item *

L<find_field|Text::Parser::AutoSplit/find_field>

=item *

L<find_field_index|Text::Parser::AutoSplit/find_field_index>

=item *

L<splice_fields|Text::Parser::AutoSplit/splice_fields>

=back

The other methods described below may also be used inside a rule, or inside methods called by the rules.

=head2 this_line

Takes no arguments, and returns the current line being parsed. For example:

    $parser->add_rule(
        if => 'length($this->this_line) > 256', 
    );
    ## Saves all lines longer than 256 characters

Inside rules, instead of using this method, one may also use C<$_>:

    $parser->add_rule(
        if => 'length($_) > 256', 
    );

=head2 abort_reading

Takes no arguments. Returns C<1>. Aborts C<read>ing any more lines, and C<read> method exits gracefully as if nothing unusual happened.

    $parser->add_rule(
        do          => '$this->abort_reading;',
        if          => '$1 eq "EOF"', 
        dont_record => 1, 
    );

=head1 OVERRIDE IN SUBCLASS

The following methods should never be called in the C<::main> program. They may be overridden (or re-defined) in a subclass. For the most part, one would never have to override any of these methods at all. But just in case someone wants to...

=head2 save_record

The default implementation takes a single argument, runs any rules, and saves the returned value as a record in an internal array. If nothing is returned from the rule, C<undef> is stored as a record.

B<Note>: Starting C<0.925> version of C<Text::Parser> it is not required to override this method in your derived class. In most cases, you should use the rules.

=head1 EXAMPLES

You can find example code in L<Text::Parser::Manual::ComparingWithNativePerl>.

=head1 THINGS TO DO FURTHER

Future versions are expected to include features to:

=over 4

=item *

read and parse from a buffer

=item *

automatically uncompress input

=item *

I<suggestions welcome ...>

=back

Contributions and suggestions are welcome and properly acknowledged.

=head1 HANDLING LINE-WRAPPING

These methods are meant to handle target text formats that support line-wrapping (wrapping content of one line into multiple lines). Different text formats sometimes allow line-wrapping to make their content more human-readable.

=head2 Common line-wrapping styles

L<Text::Parser> supports some commonly-used line-unwrapping routines which can be selected using the C<line_wrap_style> attribute. The C<line_wrap_style> attribute automatically sets up the parser to handle line-unwrapping for that specific text format.

    $parser->line_wrap_style('trailing_backslash');
    # Now when read runs the rules, all the back-slash
    # line-wrapped lines are auto-unwrapped to a single
    # line, and rules are applied on that single line

Once this setting is done, a call to C<read> will automatically unwrap the multiple lines with trailing back-slashes (i.e., join them) and then apply the rules. So say the content of a line is like this:

    This is a long line wrapped into multiple lines \
    with a back-slash character. This is a very common \
    way to wrap long lines. In general, line-wrapping \
    can be much easier on the reader's eyes.

When C<read> runs any rules in C<$parser>, the text above appears as a single line in C<$_>.

=head2 Specifying custom line-unwrap routines

To specify a custom line-unwrapping style:

=over 4

=item *

Set the C<L<multiline_type|/"multiline_type">> attribute appropriately

=item *

Call C<L<custom_line_unwrap_routines|/"custom_line_unwrap_routines">> method

=back

=head2 Line-unwrap feature in a subclass

In a subclass, you may do one of the following:

=over 4

=item *

Set a default value for C<line_wrap_style>. For example: C<has '+line_wrap_style' => ( default => 'spice', );>. This uses one of the supported common line-unwrap methods.

=item *

Setup custom line-unwrap routines with C<unwraps_lines> from L<Text::Parser::RuleSpec>.

=back

=head2 Default line-unwrap methods

The default implementation of the C<when> routine:

    multiline_type    |    Return value
    ------------------+---------------------------------
    undef             |         0
    join_last         |    0 for first line, 1 otherwise
    join_next         |         1

=head1 SEE ALSO

=over 4

=item *

L<Text::Parser::Manual> - Read this manual

=item *

L<The AWK Programming Language|https://books.google.com/books/about/The_AWK_Programming_Language.html?id=53ueQgAACAAJ> - by B<A>ho, B<W>einberg, and B<K>ernighan.

=item *

L<Text::Parser::Errors> - documentation of the exceptions this class throws

=item *

L<Text::Parser::Multiline> - how to read line-wrapped text input

=back

=head1 BUGS

Please report any bugs or feature requests on the bugtracker website
L<http://github.com/balajirama/Text-Parser/issues>

When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.

=head1 AUTHOR

Balaji Ramasubramanian <balajiram@cpan.org>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2018-2019 by Balaji Ramasubramanian.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=head1 CONTRIBUTORS

=for stopwords H.Merijn Brand - Tux Mohammad S Anwar

=over 4

=item *

H.Merijn Brand - Tux <h.m.brand@xs4all.nl>

=item *

Mohammad S Anwar <mohammad.anwar@yahoo.com>

=back

=cut
